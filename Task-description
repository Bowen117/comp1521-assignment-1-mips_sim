Assignment 1: mips_sim, MIPS simulator
version: 1.4 last updated: 2020-10-26 10:10:00

Aims
Understanding encoding of MIPS instructions
Understanding semantics of MIPS instructions
Generally building a concrete understanding of an example CPU
Practising C, including bit operations
The Assignment
Your task in this assignment is to write mips_sim a simulator for a small simple subset of the MIPS .

The input to mips_sim will be the 32-bit instruction codes for MIPS instructions as hexadecimal numbers.

The command 1521 spim2hex will give you the hex codes for MIPS instructions.

$cat examples/42.s
    li   $a0, 42          # printf("%d", 42);
    li   $v0, 1
    syscall
    li   $a0, '\n'      # printf("%c", '\n');
    li   $v0, 11
    syscall
    
$1521 spim2hex examples/42.s
  3404002a
  34020001
  c
  3404000a
  3402000b
  c

mips_sim.c should simulate executing these instruction like this:

$cat examples/42.hex
  3404002a
  34020001
  c
  3404000a
  3402000b
  c
  
$dcc mips_sim.c -o mips_sim
$./mips_sim examples/42.hex
  0: 0x3404002A ori  $4, $0, 42
  >>> $4 = 42
  1: 0x34020001 ori  $2, $0, 1
  >>> $2 = 1
  2: 0x0000000C syscall
  >>> syscall 1
  <<< 42
  3: 0x3404000A ori  $4, $0, 10
  >>> $4 = 10
  4: 0x3402000B ori  $2, $0, 11
  >>> $2 = 11
  5: 0x0000000C syscall
  >>> syscall 11
  <<<

If the command-line argument -r is given then only the output from syscalls should be shown, like this:
$./mips_sim -r examples/42.hex
  42
  
 Reference implementation
A reference implementation is available as 1521 mips_sim which can use to find the correctoutput for any input, like this:
$cat examples/square.hex
  34100004
  34110003
  72108002
  72318802
  2302020
  34020001
  c
  3404000a
  3402000b
  c
$1521 mips_sim examples/square.hex
  0: 0x34100004 ori  $16, $0, 4
  >>> $16 = 4
  1: 0x34110003 ori  $17, $0, 3
  >>> $17 = 3
  2: 0x72108002 mul  $16, $16, $16
  >>> $16 = 16
  3: 0x72318802 mul  $17, $17, $17
  >>> $17 = 9
  4: 0x02302020 add  $4, $17, $16
  >>> $4 = 25
  5: 0x34020001 ori  $2, $0, 1
  >>> $2 = 1
  6: 0x0000000C syscall
  >>> syscall 1
  <<< 25
  7: 0x3404000A ori  $4, $0, 10
  >>> $4 = 10
  8: 0x3402000B ori  $2, $0, 11
  >>> $2 = 11
  9: 0x0000000C syscall
  >>> syscall 11
  <<<

$1521 mips_sim -r examples/square.hex
  25
 
Provision of a reference implementation is a common, efficient and effective method to provide or define an operational specification, and it's something you will likely need to work with after you leave UNSW.
Where any aspect of this assignment is undefined in this specification you should match the reference implementation's behaviour.

Discovering and matching the reference implementation's behaviour is deliberately part of the assignment.

If you discover what you believe to be a bug in the reference implementation, report it in the class forum. If it is a bug, we may fix the bug, or indicate that you do not need to match the reference implementation's behaviour in this case.

Registers
All 32 registers are set to be zero when execution begins.
The value of register $0 ($zero) is always 0. Instructions which attempt to change it have no effect.

The values of registers $2 ($v0) and $4 ($a0) are used by the syscall instruction.

The other 31 registers have no special meaning and can be used for any purpose.

Halting
Execution halts if an exit syscall is executed.
Execution halts if it reaches the location after the last instruction.

Execution halts if there is a branch to the location immediately after the last instruction.

Execution halts with an error message if there is a branch to any other location beyond the range of specified instructions:
Illegal branch to address before instructions: PC = ??
Illegal branch to address after instructions: PC = ??
